#!/usr/bin/env python3
"""
LAN Security Monitor - Vulnerability Detection Module
Detects common security vulnerabilities and misconfigurations.
"""

import socket
import ssl
import requests
import logging
from datetime import datetime, timedelta
import json
import subprocess
import threading
from concurrent.futures import ThreadPoolExecutor

class VulnerabilityDetector:
    def __init__(self):
        self.vulnerabilities = []
        self.setup_logging()
        
    def setup_logging(self):
        """Setup logging configuration"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('vulnerability_scan.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)

    def check_weak_passwords(self, ip, port, service):
        """Check for weak/default passwords"""
        weak_passwords = [
            ('admin', 'admin'), ('admin', 'password'), ('admin', '123456'),
            ('root', 'root'), ('root', 'password'), ('root', 'toor'),
            ('user', 'user'), ('guest', 'guest'), ('test', 'test'),
            ('administrator', 'administrator'), ('sa', ''), ('postgres', 'postgres')
        ]
        
        vulnerabilities = []
        
        if service.lower() in ['ssh', 'telnet', 'ftp']:
            for username, password in weak_passwords:
                if self.test_login(ip, port, service, username, password):
                    vulnerabilities.append({
                        'type': 'Weak Credentials',
                        'severity': 'HIGH',
                        'description': f'Weak credentials found: {username}:{password}',
                        'service': service,
                        'port': port,
                        'recommendation': 'Change default passwords immediately'
                    })
                    
        return vulnerabilities

    def test_login(self, ip, port, service, username, password):
        """Test login credentials (simplified implementation)"""
        try:
            if service.lower() == 'ssh':
                return self.test_ssh_login(ip, port, username, password)
            elif service.lower() == 'ftp':
                return self.test_ftp_login(ip, port, username, password)
            elif service.lower() == 'telnet':
                return self.test_telnet_login(ip, port, username, password)
        except Exception as e:
            self.logger.debug(f"Login test failed for {ip}:{port} - {e}")
        return False

    def test_ssh_login(self, ip, port, username, password):
        """Test SSH login (requires paramiko for full implementation)"""
        # This is a placeholder - in production, use paramiko
        return False

    def test_ftp_login(self, ip, port, username, password):
        """Test FTP login"""
        try:
            import ftplib
            ftp = ftplib.FTP()
            ftp.connect(ip, port, timeout=5)
            ftp.login(username, password)
            ftp.quit()
            return True
        except:
            return False

    def test_telnet_login(self, ip, port, username, password):
        """Test Telnet login"""
        # Placeholder - telnet login testing is complex
        return False

    def check_ssl_vulnerabilities(self, ip, port):
        """Check for SSL/TLS vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check SSL certificate
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((ip, port), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=ip) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Check certificate expiration
                    if cert:
                        not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                        days_until_expiry = (not_after - datetime.now()).days
                        
                        if days_until_expiry < 30:
                            vulnerabilities.append({
                                'type': 'SSL Certificate Expiry',
                                'severity': 'MEDIUM' if days_until_expiry > 7 else 'HIGH',
                                'description': f'SSL certificate expires in {days_until_expiry} days',
                                'port': port,
                                'recommendation': 'Renew SSL certificate before expiration'
                            })
                    
                    # Check SSL version
                    ssl_version = ssock.version()
                    if ssl_version in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                        vulnerabilities.append({
                            'type': 'Weak SSL/TLS Version',
                            'severity': 'HIGH',
                            'description': f'Weak SSL/TLS version: {ssl_version}',
                            'port': port,
                            'recommendation': 'Upgrade to TLS 1.2 or higher'
                        })
                        
        except Exception as e:
            self.logger.debug(f"SSL check failed for {ip}:{port} - {e}")
            
        return vulnerabilities

    def check_open_ports_risk(self, ports):
        """Check for risky open ports"""
        vulnerabilities = []
        
        risky_ports = {
            21: {'service': 'FTP', 'risk': 'HIGH', 'reason': 'Unencrypted file transfer'},
            23: {'service': 'Telnet', 'risk': 'HIGH', 'reason': 'Unencrypted remote access'},
            25: {'service': 'SMTP', 'risk': 'MEDIUM', 'reason': 'Potential mail relay'},
            53: {'service': 'DNS', 'risk': 'MEDIUM', 'reason': 'DNS amplification attacks'},
            135: {'service': 'RPC', 'risk': 'HIGH', 'reason': 'Windows RPC vulnerabilities'},
            139: {'service': 'NetBIOS', 'risk': 'HIGH', 'reason': 'SMB vulnerabilities'},
            445: {'service': 'SMB', 'risk': 'HIGH', 'reason': 'SMB vulnerabilities (WannaCry, etc.)'},
            1433: {'service': 'MSSQL', 'risk': 'MEDIUM', 'reason': 'Database exposure'},
            3306: {'service': 'MySQL', 'risk': 'MEDIUM', 'reason': 'Database exposure'},
            3389: {'service': 'RDP', 'risk': 'HIGH', 'reason': 'Remote desktop vulnerabilities'},
            5432: {'service': 'PostgreSQL', 'risk': 'MEDIUM', 'reason': 'Database exposure'},
            6379: {'service': 'Redis', 'risk': 'HIGH', 'reason': 'Often misconfigured without auth'}
        }
        
        for port_info in ports:
            port = port_info.get('port') if isinstance(port_info, dict) else port_info
            
            if port in risky_ports:
                risk_info = risky_ports[port]
                vulnerabilities.append({
                    'type': 'Risky Open Port',
                    'severity': risk_info['risk'],
                    'description': f'{risk_info["service"]} service exposed on port {port}',
                    'port': port,
                    'reason': risk_info['reason'],
                    'recommendation': f'Consider closing port {port} or implementing proper security controls'
                })
                
        return vulnerabilities

    def check_web_vulnerabilities(self, ip, port):
        """Check for common web vulnerabilities"""
        vulnerabilities = []
        
        try:
            base_url = f"http://{ip}:{port}"
            if port == 443:
                base_url = f"https://{ip}:{port}"
                
            # Check for directory listing
            response = requests.get(f"{base_url}/", timeout=5, verify=False)
            if "Index of" in response.text or "Directory Listing" in response.text:
                vulnerabilities.append({
                    'type': 'Directory Listing Enabled',
                    'severity': 'MEDIUM',
                    'description': 'Web server allows directory browsing',
                    'port': port,
                    'recommendation': 'Disable directory listing in web server configuration'
                })
            
            # Check for common admin panels
            admin_paths = ['/admin', '/administrator', '/wp-admin', '/phpmyadmin', '/cpanel']
            for path in admin_paths:
                try:
                    admin_response = requests.get(f"{base_url}{path}", timeout=3, verify=False)
                    if admin_response.status_code == 200:
                        vulnerabilities.append({
                            'type': 'Admin Panel Exposed',
                            'severity': 'MEDIUM',
                            'description': f'Admin panel accessible at {path}',
                            'port': port,
                            'recommendation': 'Restrict access to admin panels'
                        })
                except:
                    continue
            
            # Check security headers
            headers = response.headers
            missing_headers = []
            
            security_headers = [
                'X-Frame-Options',
                'X-Content-Type-Options',
                'X-XSS-Protection',
                'Strict-Transport-Security',
                'Content-Security-Policy'
            ]
            
            for header in security_headers:
                if header not in headers:
                    missing_headers.append(header)
            
            if missing_headers:
                vulnerabilities.append({
                    'type': 'Missing Security Headers',
                    'severity': 'LOW',
                    'description': f'Missing security headers: {", ".join(missing_headers)}',
                    'port': port,
                    'recommendation': 'Implement proper security headers'
                })
                
        except Exception as e:
            self.logger.debug(f"Web vulnerability check failed for {ip}:{port} - {e}")
            
        return vulnerabilities

    def check_smb_vulnerabilities(self, ip, port):
        """Check for SMB vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check for SMBv1 (vulnerable to WannaCry)
            # This is a simplified check - in production, use proper SMB libraries
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((ip, port))
            
            if result == 0:
                vulnerabilities.append({
                    'type': 'SMB Service Exposed',
                    'severity': 'HIGH',
                    'description': 'SMB service is accessible from network',
                    'port': port,
                    'recommendation': 'Ensure SMB is properly secured and updated'
                })
            
            sock.close()
            
        except Exception as e:
            self.logger.debug(f"SMB check failed for {ip}:{port} - {e}")
            
        return vulnerabilities

    def check_database_exposure(self, ip, port, service):
        """Check for exposed databases"""
        vulnerabilities = []
        
        database_ports = {
            1433: 'MSSQL',
            3306: 'MySQL',
            5432: 'PostgreSQL',
            6379: 'Redis',
            27017: 'MongoDB'
        }
        
        if port in database_ports:
            vulnerabilities.append({
                'type': 'Database Exposure',
                'severity': 'HIGH',
                'description': f'{database_ports[port]} database accessible from network',
                'port': port,
                'recommendation': 'Restrict database access to authorized hosts only'
            })
            
        return vulnerabilities

    def scan_device_vulnerabilities(self, device_info):
        """Scan a single device for vulnerabilities"""
        ip = device_info['ip']
        ports = device_info.get('ports', [])
        
        device_vulnerabilities = []
        
        self.logger.info(f"Scanning vulnerabilities for {ip}")
        
        # Check risky open ports
        device_vulnerabilities.extend(self.check_open_ports_risk(ports))
        
        # Check each open port for specific vulnerabilities
        for port_info in ports:
            if isinstance(port_info, dict):
                port = port_info.get('port')
                service = port_info.get('service', 'unknown')
            else:
                port = port_info
                service = 'unknown'
            
            # Check for weak passwords
            device_vulnerabilities.extend(self.check_weak_passwords(ip, port, service))
            
            # Check SSL vulnerabilities for HTTPS ports
            if port in [443, 8443] or 'https' in service.lower():
                device_vulnerabilities.extend(self.check_ssl_vulnerabilities(ip, port))
            
            # Check web vulnerabilities for HTTP ports
            if port in [80, 8080, 443, 8443] or 'http' in service.lower():
                device_vulnerabilities.extend(self.check_web_vulnerabilities(ip, port))
            
            # Check SMB vulnerabilities
            if port in [139, 445] or 'smb' in service.lower():
                device_vulnerabilities.extend(self.check_smb_vulnerabilities(ip, port))
            
            # Check database exposure
            device_vulnerabilities.extend(self.check_database_exposure(ip, port, service))
        
        # Add device info to each vulnerability
        for vuln in device_vulnerabilities:
            vuln['ip'] = ip
            vuln['hostname'] = device_info.get('hostname', 'Unknown')
            vuln['scan_time'] = datetime.now().isoformat()
        
        return device_vulnerabilities

    def scan_all_devices(self, devices):
        """Scan all devices for vulnerabilities"""
        self.vulnerabilities = []
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = {executor.submit(self.scan_device_vulnerabilities, device): ip 
                      for ip, device in devices.items()}
            
            for future in futures:
                try:
                    device_vulns = future.result()
                    self.vulnerabilities.extend(device_vulns)
                except Exception as e:
                    ip = futures[future]
                    self.logger.error(f"Error scanning vulnerabilities for {ip}: {e}")
        
        return self.vulnerabilities

    def generate_report(self):
        """Generate vulnerability report"""
        report = {
            'scan_time': datetime.now().isoformat(),
            'total_vulnerabilities': len(self.vulnerabilities),
            'severity_breakdown': {
                'HIGH': len([v for v in self.vulnerabilities if v['severity'] == 'HIGH']),
                'MEDIUM': len([v for v in self.vulnerabilities if v['severity'] == 'MEDIUM']),
                'LOW': len([v for v in self.vulnerabilities if v['severity'] == 'LOW'])
            },
            'vulnerabilities': self.vulnerabilities
        }
        
        return report

    def save_report(self, filename="vulnerability_report.json"):
        """Save vulnerability report to file"""
        try:
            report = self.generate_report()
            with open(filename, 'w') as f:
                json.dump(report, f, indent=2)
            self.logger.info(f"Vulnerability report saved to {filename}")
        except Exception as e:
            self.logger.error(f"Error saving report: {e}")

    def print_summary(self):
        """Print vulnerability summary"""
        print("\n" + "="*60)
        print("VULNERABILITY SCAN SUMMARY")
        print("="*60)
        
        report = self.generate_report()
        
        print(f"Total vulnerabilities found: {report['total_vulnerabilities']}")
        print(f"HIGH severity: {report['severity_breakdown']['HIGH']}")
        print(f"MEDIUM severity: {report['severity_breakdown']['MEDIUM']}")
        print(f"LOW severity: {report['severity_breakdown']['LOW']}")
        print(f"Scan completed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("\n")
        
        # Group vulnerabilities by device
        devices = {}
        for vuln in self.vulnerabilities:
            ip = vuln['ip']
            if ip not in devices:
                devices[ip] = []
            devices[ip].append(vuln)
        
        for ip, vulns in devices.items():
            print(f"Device: {ip}")
            hostname = vulns[0].get('hostname', 'Unknown')
            print(f"  Hostname: {hostname}")
            print(f"  Vulnerabilities: {len(vulns)}")
            
            for vuln in vulns:
                print(f"    [{vuln['severity']}] {vuln['type']}")
                print(f"      {vuln['description']}")
                if 'port' in vuln:
                    print(f"      Port: {vuln['port']}")
                print(f"      Recommendation: {vuln['recommendation']}")
                print()

def main():
    """Main function for standalone execution"""
    print("LAN Security Monitor - Vulnerability Scanner")
    print("===========================================")
    
    # Load network scan results
    try:
        with open('network_scan_results.json', 'r') as f:
            devices = json.load(f)
    except FileNotFoundError:
        print("Error: network_scan_results.json not found.")
        print("Please run network_scanner.py first to discover devices.")
        return
    
    detector = VulnerabilityDetector()
    
    print(f"Scanning {len(devices)} devices for vulnerabilities...")
    vulnerabilities = detector.scan_all_devices(devices)
    
    detector.print_summary()
    detector.save_report()

if __name__ == "__main__":
    main()
